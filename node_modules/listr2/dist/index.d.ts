import * as colorette from 'colorette';

/**
 * Indicates an UNICODE characters is coming up.
 */
declare const ANSI_ESCAPE = "\u001B[";
/**
 * Generic ANSI escape characters for terminal based operations.
 */
declare const ANSI_ESCAPE_CODES: {
    CURSOR_HIDE: string;
    CURSOR_SHOW: string;
};

/**
 * Environment variables for Listr.
 */
declare enum ListrEnvironmentVariables {
    FORCE_UNICODE = "LISTR_FORCE_UNICODE",
    FORCE_TTY = "LISTR_FORCE_TTY",
    DISABLE_COLOR = "NO_COLOR",
    FORCE_COLOR = "FORCE_COLOR"
}

/**
 * The actual error type that is collected and to help identify where the error is triggered from.
 */
declare enum ListrErrorTypes {
    /** Task has failed and will try to retry. */
    WILL_RETRY = "WILL_RETRY",
    /** Task has failed and will try to rollback. */
    WILL_ROLLBACK = "WILL_ROLLBACK",
    /** Task has failed, ran the rollback action but the rollback action itself has failed. */
    HAS_FAILED_TO_ROLLBACK = "HAS_FAILED_TO_ROLLBACK",
    /** Task has failed. */
    HAS_FAILED = "HAS_FAILED",
    /** Task has failed, but exitOnError is set to false, so will ignore this error. */
    HAS_FAILED_WITHOUT_ERROR = "HAS_FAILED_WITHOUT_ERROR"
}

/**
 * Events that are triggered by Listr.
 *
 * These are stateful and singleton events by being attached to the main Listr class and propagating to the subtasks.
 *
 * @see {@link https://listr2.kilic.dev/listr/events.html}
 */
declare enum ListrEventType {
    /** Indicates that underlying renderer should refresh the current render. */
    SHOULD_REFRESH_RENDER = "SHOUD_REFRESH_RENDER"
}

declare enum ListrRendererSelection {
    PRIMARY = "PRIMARY",
    SECONDARY = "SECONDARY",
    SILENT = "SILENT"
}

/**
 * Internal events that are fired from the Task.
 *
 * @see {@link https://listr2.kilic.dev/task/events.html}
 */
declare enum ListrTaskEventType {
    /** Title has changed for the current Task. */
    TITLE = "TITLE",
    /**
     * State has changed for the current Task.
     *
     * @see {@link module:listr2.ListrTaskState}
     */
    STATE = "STATE",
    /** The current Task has been marked as enabled. */
    ENABLED = "ENABLED",
    /** The current Task is currently processing subtasks. */
    SUBTASK = "SUBTASK",
    /** The current Task is now processing a prompt. */
    PROMPT = "PROMPT",
    /** The current Task is now dumping output. */
    OUTPUT = "OUTPUT",
    /**
     * The current Task is now dumping a message.
     *
     * @see {module:Listr2.ListrTaskMessage}
     */
    MESSAGE = "MESSAGE",
    /** The current Task is closed and no further action in expected. */
    CLOSED = "CLOSED"
}

/**
 * Tasks can be in various states during the execution.
 *
 * Whenever a state change occurs, the task will emit a {@link module:listr2.ListrTaskEventType.STATE} with the appropriate state.
 */
declare enum ListrTaskState {
    /** Task has not started yet, waiting for pick-up. */
    WAITING = "WAITING",
    /** Task has started. */
    STARTED = "STARTED",
    /** Task has been completed. */
    COMPLETED = "COMPLETED",
    /** Task has failed. */
    FAILED = "FAILED",
    /** Task has been skipped. */
    SKIPPED = "SKIPPED",
    /** Task is currently trying to rollback. */
    ROLLING_BACK = "ROLLING_BACK",
    /** Task has rolledback successfully after failing. */
    ROLLED_BACK = "ROLLED_BACK",
    /** Task is currently retrying. */
    RETRY = "RETRY",
    /** Task is currently paused. */
    PAUSED = "PAUSED",
    /** Task is currently trying to process a prompt. */
    PROMPT = "PROMPT",
    /** Task has successfully processed the prompt. */
    PROMPT_COMPLETED = "PROMPT_COMPLETED",
    /** Task has failed to process the prompt. */
    PROMPT_FAILED = "PROMPT_FAILED"
}

interface ObserverLike<T> {
    next: (value: T) => void;
    complete: () => void;
    error: (err: unknown) => void;
}
interface ObservableLike<T = any> {
    subscribe: (observer: ObserverLike<T>) => unknown;
}
interface ReadableLike {
    readable: boolean;
    read: (size?: number) => string | Buffer;
    on: (eventName: 'data' | 'error' | 'end', listener: (data: Buffer | string) => void) => unknown;
}

/**
 * Give event map a set of indexes to not make it go crazy when some events are missing from it.
 * They are optional after all.
 */
declare class BaseEventMap {
    [k: string]: any;
}
/**
 * Parameters for the given event in the {@link EventMap}.
 */
type EventData<Event extends string, Map extends Record<string, unknown>> = Event extends keyof Map ? Map[Event] : never;
/**
 * An event map of given events that defined the parameters and return types for firing a certain event.
 */
type EventMap<Events extends string> = Partial<Record<Events, unknown>>;

declare class EventManager<Event extends string = string, Map extends Partial<Record<Event, unknown>> = Partial<Record<Event, any>>> {
    private readonly emitter;
    emit<E extends Event = Event>(dispatch: E, args?: EventData<E, Map>): void;
    on<E extends Event = Event>(dispatch: E, handler: (data: EventData<E, Map>) => void): void;
    once<E extends Event = Event>(dispatch: E, handler: (data: EventData<E, Map>) => void): void;
    off<E extends Event = Event>(dispatch: E, handler?: (data: EventData<E, Map>) => void): void;
    complete(): void;
}

/**
 * Tests to see if the object is an RxJS {@link Observable}
 * @param obj the object to test
 */
declare function isObservable<T>(obj: any): obj is ObservableLike<T>;

/**
 * Tests to see if the object is an Readable or NodeJS.ReadableStream {@link Readable, NodeJS.ReadableStream}
 * @param obj the object to test
 */
declare function isReadable(obj: any): obj is ReadableLike;

declare function isUnicodeSupported(): boolean;

declare function cleanseAnsi(chunk: string): string;

/**
 * Creates color palette through underlying dependency of `colorette`.
 *
 * @see {@link https://www.npmjs.com/package/colorette}
 */
declare const color: colorette.Colorette;

declare function indent(string: string, count: number): string;

declare const FIGURES_MAIN: {
    warning: string;
    cross: string;
    arrowDown: string;
    tick: string;
    arrowRight: string;
    pointer: string;
    checkboxOn: string;
    arrowLeft: string;
    squareSmallFilled: string;
    pointerSmall: string;
};
type Figures = typeof FIGURES_MAIN;
declare const figures: Figures;

declare function splat(message: string, ...splat: any[]): string;

/**
 * Creates a new Listr2 logger.
 *
 * This logger is used throughout the renderers for consistency.
 *
 * @see {@link https://listr2.kilic.dev/renderer/logger.html}
 */
declare class ListrLogger<Levels extends string = string> {
    options?: ListrLoggerOptions<Levels>;
    readonly process: ProcessOutput;
    constructor(options?: ListrLoggerOptions<Levels>);
    log(level: Levels, message: string | any[], options?: LoggerFieldOptions): void;
    toStdout(message: string | any[], options?: LoggerFieldOptions, eol?: boolean): void;
    toStderr(message: string | any[], options?: LoggerFieldOptions, eol?: boolean): void;
    wrap(message: string, options?: LoggerFormatOptions): string;
    splat(...args: Parameters<typeof splat>): ReturnType<type