(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.jsonExt = factory());
}(typeof globalThis != 'undefined' ? globalThis : typeof window != 'undefined' ? window : typeof global != 'undefined' ? global : typeof self != 'undefined' ? self : this, (function () {
var exports = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/index.js
  var src_exports = {};
  __export(src_exports, {
    createStringifyWebStream: () => createStringifyWebStream,
    parseChunked: () => parseChunked,
    parseFromWebStream: () => parseFromWebStream,
    stringifyChunked: () => stringifyChunked,
    stringifyInfo: () => stringifyInfo
  });

  // src/utils.js
  function isIterable(value) {
    return typeof value === "object" && value !== null && (typeof value[Symbol.iterator] === "function" || typeof value[Symbol.asyncIterator] === "function");
  }
  function replaceValue(holder, key, value, replacer) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (replacer !== null) {
      value = replacer.call(holder, String(key), value);
    }
    switch (typeof value) {
      case "function":
      case "symbol":
        value = void 0;
        break;
      case "object":
        if (value !== null) {
          const cls = value.constructor;
          if (cls === String || cls === Number || cls === Boolean) {
            value = value.valueOf();
          }
        }
        break;
    }
    return value;
  }
  function normalizeReplacer(replacer) {
    if (typeof replacer === "function") {
      return replacer;
    }
    if (Array.isArray(replacer)) {
      const allowlist = new Set(
        replacer.map((item) => {
          const cls = item && item.constructor;
          return cls === String || cls === Number ? String(item) : null;
        }).filter((item) => typeof item === "string")
      );
      return [...allowlist];
    }
    return null;
  }
  function normalizeSpace(space) {
    if (typeof space === "number") {
      if (!Number.isFinite(space) || space < 1) {
        return false;
      }
      return " ".repeat(Math.min(space, 10));
    }
    if (typeof space === "string") {
      return space.slice(0, 10) || false;
    }
    return false;
  }

  // src/parse-chunked.js
  var STACK_OBJECT = 1;
  var STACK_ARRAY = 2;
  var decoder = new TextDecoder();
  function adjustPosition(error, parser) {
    if (error.name === "SyntaxError" && parser.jsonParseOffset) {
      error.message = error.message.replace(
        /at position (\d+)/,
        (_, pos) => "at position " + (Number(pos) + parser.jsonParseOffset)
      );
    }
    return error;
  }
  function append(array, elements) {
    const initialLength = array.length;
    array.length += elements.length;
    for (let i = 0; i < elements.length; i++) {
      array[initialLength + i] = elements[i];
    }
  }
  async function parseChunked(chunkEmitter) {
    const iterable = typeof chunkEmitter === "function" ? chunkEmitter() : chunkEmitter;
    if (isIterable(iterable)) {
      let parser = new ChunkParser();
      try {
        for await (const chunk of iterable) {
          if (typeof chunk !== "string" && !ArrayBuffer.isView(chunk)) {
            throw new TypeError("Invalid chunk: Expected string, TypedArray or Buffer");
          }
          parser.push(chunk);
        }
        return parser.finish();
      } catch (e) {
        throw adjustPosition(e, parser);
      }
    }
    throw new TypeError(
      "Invalid chunk emitter: Expected an Iterable, AsyncIterable, generator, async generator, or a function returning an Iterable or AsyncIterable"
    );
  }
  var ChunkParser = class {
    constructor() {
      this.value = void 0;
      this.valueStack = null;
      this.stack = new Array(100);
      this.lastFlushDepth = 0;
      this.flushDepth = 0;
      this.stateString = false;
      this.stateStringEscape = false;
      this.pendingByteSeq = null;
      this.pendingChunk = null;
      this.chunkOffset = 0;
      this.jsonParseOffset = 0;
    }
    parseAndAppend(fragment, wrap) {
      if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {
        if (wrap) {
          this.jsonParseOffset--;
          fragment = "{" + fragment + "}";
        }
        Object.assign(this.valueStack.value, JSON.parse(fragment));
      } else {
        if (wrap) {
          this.jsonParseOffset--;
          fragment = "[" + fragment + "]";
        }
        append(this.valueStack.value, JSON.parse(fragment));
      }
    }
    prepareAddition(fragment) {
      const { value } = this.valueStack;
      const expectComma = Array.isArray(value) ? value.length !== 0 : Object.keys(value).length !== 0;
      if (expectComma) {
        if (fragment[0] === ",") {
          this.jsonParseOffset++;
          return fragment.slice(1);
        }
        if (fragment[0] !== "}" && fragment[0] !== "]") {
          this.jsonParseOffset -= 3;
          return "[[]" + fragment;
        }
      }
      return fragment;
    }
    flush(chunk, start, end) {
      let fragment = chunk.slice(start, end);
      this.jsonParseOffset = this.chunkOffset + start;
      if (this.pendingChunk !== null) {
        fragment = this.pendingChunk + fragment;
        this.jsonParseOffset -= this.pendingChunk.length;
        this.pendingChunk = null;
      }
      if (this.flushDepth === this.lastFlushDepth) {
        if (this.flushDepth > 0) {
          this.parseAndAppend(this.prepareAddition(fragment), true);
        } else {
          this.value = JSON.parse(fragment);
          this.valueStack = {
            value: this.value,
            prev: null
          };
        }
      } else if (this.flushDepth > this.lastFlushDepth) {
        for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {
          fragment += this.stack[i] === STACK_OBJECT ? "}" : "]";
        }
        if (this.lastFlushDepth === 0) {
          this.value = JSON.parse(fragment);
          this.valueStack = {
            value: this.value,
            prev: null
          };
        } else {
          this.parseAndAppend(this.prepareAddition(fragment), true);
        }
        for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {
          let value = this.valueStack.value;
          if (this.stack[i - 1] === STACK_OBJECT) {
            let key;
            for (key in value) ;
            value = value[key];
          } else {
            value = value[value.length - 1];
          }
          this.valueStack = {
            value,
            prev: this.valueStack
          };
        }
      } else {
        fragment = this.prepareAddition(fragment);
        for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {
          this.jsonParseOffset--;
          fragment = (this.stack[i] === STACK_OBJECT ? "{" : "[") + fragment;
        }
        this.parseAndAppend(fragment, false);
        for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {
          this.valueStack = this.valueStack.prev;
        }
      }
      this.lastFlushDepth = this.flushDepth;
    }
    push(chunk) {
      if (typeof chunk !== "string") {
        if (this.pendingByteSeq !== null) {
          const origRawChunk = chunk;
          chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);
          chunk.set(this.pendingByteSeq);
          chunk.set(origRawChunk, this.pendingByteSeq.length);
          this.pendingByteSeq = null;
        }
        if (chunk[chunk.length - 1] > 127) {
          for (let seqLength = 0; seqLength < chunk.length; seqLength++) {
            const byte = chunk[chunk.length - 1 - seqLength];
            if (byte >> 6 === 3) {
              seqLength++;
              if (seqLength !== 4 && byte >> 3 === 30 || seqLength !== 3 && byte >> 4 === 14 || seqLength !== 2 && byte >> 5 === 6) {
                this.pendingByteSeq = chunk.slice(chunk.length - seqLength);
                chunk = chunk.slice(0, -seqLength);
              }
              break;
            }
          }
        }
        chunk = decoder.decode(chunk);
      }
      const chunkLength = chunk.length;
      let lastFlushPoint = 0;
      let flushPoint = 0;
      scan: for (let i = 0; i < chunkLength; i++) {
        if (this.stateString) {
          for (; i < chunkLength; i++) {
            if (this.stateStringEscape) {
              this.stateStringEscape = false;
            } else {
              switch (chunk.charCodeAt(i)) {
                case 34:
                  this.stateString = false;
                  continue scan;
                case 92:
                  this.stateStringEscape = true;
              }
            }
          }
          break;
        }
        switch (chunk.charCodeAt(i)) {
          case 34:
            this.stateString = true;
            this.stateStringEscape = false;
            break;
          case 44:
            flushPoint = i;
            break;
          case 123:
            flushPoint = i + 1;
            this.stack[this.flushDepth++] = STACK_OBJECT;
            break;
          case 91:
            flushPoint = i + 1;
            this.stack[this.flushDepth++] = STACK_ARRAY;
            break;
          case 93:
          case 125:
            flushPoint = i + 1;
            this.flushDepth--;
            if (this.flushDepth < this.lastFlushDepth) {
              this.flush(chunk, lastFlushPoint, flushPoint);
              lastFlushPoint = flushPoint;
            }
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            if (lastFlushPoint === i) {
              lastFlushPoint++;
            }
            if (flushPoint === i) {
              flushPoint++;
            }
            break;
        }
      }
      if (flushPoint > lastFlushPoint) {
        this.flush(chunk, lastFlushPoint, flushPoint);
      }
      if (flushPoint < chunkLength) {
        if (this.pendingChunk !== null) {
          this.pendingChunk += chunk;
        } else {
          this.pendingChunk = chunk.slice(flushPoint, chunkLength);
        }
      }
      this.chunkOffset += chunkLength;
    }
    finish() {
      if (this.pendingChunk !== null) {
        this.flush("", 0, 0);
        this.pendingChunk = null;
      }
      return this.value;
    }
  };

  // src/stringify-chunked.js
  function encodeString(value) {
    